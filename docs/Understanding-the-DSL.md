---
layout: doc
title: Understanding the DSL
---

Let's have a look at Daleq's concepts. They are actually very simple.

![just three things](http://yuml.me/4111ad55)

We have a Table containing Rows. And these have Fields. Nothing we would not have expected.

## Table Definitions
Assume you have such a database
{% highlight sql%}    
CREATE TABLE PRODUCT (
  ID    INT  GENERATED BY DEFAULT AS SEQUENCE PRODUCT_SEQ,
  NAME  VARCHAR(250) NOT NULL,
  SIZE  VARCHAR(250) NOT NULL,
  PRICE DECIMAL(10,2) NOT NULL,
  PRIMARY KEY (ID)
);
{% endhighlight %}
    

Daleq needs to know how your table looks like. You may explain this to Daleq by writing a Table Definition:

{% highlight java%}
@TableDef("PRODUCT")
public class ProductTable {
    public static final FieldDef ID    = Daleq.fd(DataType.INTEGER);
    public static final FieldDef NAME  = Daleq.fd(DataType.VARCHAR);
    public static final FieldDef SIZE  = Daleq.fd(DataType.VARCHAR);
    public static final FieldDef PRICE = Daleq.fd(DataType.DECIMAL);
}
{% endhighlight %}


A Table Definition is a simple class annotated by ```@TableDef``` and containing a few constants of a ```FieldDef``` type, we call Field Definitions. ```@TableDef``` requires the actual table name as a parameter. 

Each column in your table has to be modeled with a ```FieldDef```. You need to specify the SQL data type as a mandatory argument. Daleq assumes your column name is the given constant name. If this is not possible, it allows you to specify a name on your own:

{% highlight java%}
public static final FieldDef NAME  = Daleq.fd(DataType.VARCHAR).name("THE_ACTUAL_COLUMN_NAME");
{% endhighlight %}

## About the DSL

_Embedded DSL_ is actually another word for having a proper abstraction for your domain, with as much boilerplate removed as possible. Daleq does it by consisting of builders with a fluent interface and asking you for some static imports:

{% highlight java%}
import static de.brands4friends.daleq.core.Daleq.*
import static de.example.ProductTable.*
{% endhighlight %}

From now on we assume, that we have these static imports in the upcoming examples.

## Filling Tables

Lets start simple:

### Table and Row

{% highlight java%}
final Table products =
    aTable(ProductTable.class).with(
        aRow(1)
);
{% endhighlight %}

This yields

| ID | NAME | SIZE | PRICE |
|---:|:-----|:-----|------:|
| 1 | ? | ? | ? |
{: .table .table-bordered .table-condensed .table-striped}

Let's start with the simple things: Obviously we got ```Daleq.aTable(Class<T>)``` and ```Daleq.aRow(long)``` statically imported.

We define a ```ProductTable``` table having a single row. Daleq wants us to identify the row with an ID. Simplified this ID is used as the primary key in our table and it helps us later on to make proper assertions.

By now Daleq has created a table containing a single row. We know that the ID of your PRODUCT is 0 and that other columns are filled properly. We do not know what they contain.

### Fields

{% highlight java%}
final Table products =
    aTable(ProductTable.class).with(
        aRow(1).f(NAME,"Red Shirt")
);
{% endhighlight %}

| ID | NAME | SIZE | PRICE |
|---:|:-----|:-----|------:|
| 1 | Red Shirt | ? | ? |
{: .table .table-bordered .table-condensed .table-striped}

We tell a row to contain a certain field by calling ```f()``` with the respective Field Definition and a proper value. And again, since ```ProductTable.NAME``` is statically imported, it is sufficient to reference just  ```NAME```. Another reason why we a Table Definition consist of constants is that we benefit from an IDE's code completion when writing Daleq tables.

### More Fields

{% highlight java%}
final Table products = 	
    aTable(ProductTable.class).with(
        aRow(1).f(NAME,"Red Shirt").f(SIZE,"XS")
);
{% endhighlight %}

| ID | NAME | SIZE | PRICE |
|---:|:-----|:-----|------:|
| 1 | Red Shirt | XS | ? |
{: .table .table-bordered .table-condensed .table-striped}


Calling ```aRow()``` returns an instance of ```Row```, which is a builder with a fluent interface. This means, most of its methods return ```Row``` and therefore enable you to chain those methods to write even more concise code.


### More Rows

{% highlight java%}
final Table products = 	
    aTable(ProductTable.class).with(
        aRow(1), aRow(2), aRow(3)
);
{% endhighlight %}

| ID | NAME | SIZE | PRICE |
|---:|:-----|:-----|------:|
| 1 | ? | ? | ? |
| 2 | ? | ? | ? |
| 3 | ? | ? | ? |
{: .table .table-bordered .table-condensed .table-striped}

You can add any number of rows with ```with()```. This makes sense, if you want to set individual fields on each row explicitly.

If you just want to add arbitrary rows, it is even simpler:

{% highlight java%}
final Table products = 	
    aTable(ProductTable.class).withRowsBetween(1,5);
{% endhighlight %}

| ID | NAME | SIZE | PRICE |
|---:|:-----|:-----|------:|
| 1 | ? | ? | ? |
| 2 | ? | ? | ? |
| 3 | ? | ? | ? |
| 4 | ? | ? | ? |
| 5 | ? | ? | ? |
{: .table .table-bordered .table-condensed .table-striped}

Note, that the limit 5 is inclusive!

### Modifying a batch of rows

You can change all rows of the table with ```allHaving()```:

{% highlight java%}
final Table products = 
    aTable(ProductTable.class)
        .withRowsBetween(1,5)
        .allHaving(SIZE,"XS");
{% endhighlight %}

| ID | NAME | SIZE | PRICE |
|---:|:-----|:-----|------:|
| 1 | ? | XS | ? |
| 2 | ? | XS | ? |
| 3 | ? | XS | ? |
| 4 | ? | XS | ? |
| 5 | ? | XS | ? |
{: .table .table-bordered .table-condensed .table-striped}

Or with ```having()```: 

{% highlight java%}
final Table products = 	
    aTable(ProductTable.class)
        .withRowsBetween(1,5)
        .having(SIZE,"XS","S","M","L","XL");
{% endhighlight %}

| ID | NAME | SIZE | PRICE |
|---:|:-----|:-----|------:|
| 1 | ? | XS | ? |
| 2 | ? | S  | ? |
| 3 | ? | M  | ? |
| 4 | ? | L  | ? |
| 5 | ? | XL | ? |
{: .table .table-bordered .table-condensed .table-striped}

These methods just alter the already existing rows, hence appending further rows yields the expected result


{% highlight java%}
final Table products = 	
    aTable(ProductTable.class)
        .withRowsBetween(1,5)
        .allHaving(SIZE,"XS")
        .with(aRow(6).f(SIZE,"L"));
{% endhighlight %}

| ID | NAME | SIZE | PRICE |
|---:|:-----|:-----|------:|
| 1 | ? | XS | ? |
| 2 | ? | XS | ? |
| 3 | ? | XS | ? |
| 4 | ? | XS | ? |
| 5 | ? | XS | ? |
| 6 | ? | L | ? |
{: .table .table-bordered .table-condensed .table-striped}

## What to do with tables?

Now we've learned how to set up tables with all those precious rows. But what can we do with them. There are basically a few options. All of them require you to have an instance of DaleqSupport:

{% highlight java%}
private DaleqSupport daleq;
{% endhighlight %}

### Saving tables into the Database

Use ```DaleqSupport.inserIntoDatabase()``` to do what it says:

{% highlight java%}
daleq.insertIntoDatabase(
        aTable(ProductTable.class)
                .with(aRow(10).f(SIZE, "S"))
);
{% endhighlight %}

Once a table is written into the Database, you are free to so whatever you want with it. Usually you want to run your queries on them and assert that the results are correct

{% highlight java%}
@Test
public void findBySize_should_returnThoseProductsHavingThatSize() {
    daleq.insertIntoDatabase(
            aTable(ProductTable.class)
                    .withRowsUntil(10)
                    .with(
                            aRow(10).f(SIZE, "S"),
                            aRow(11).f(SIZE, "S"),
                            aRow(12).f(SIZE, "M"),
                            aRow(13).f(SIZE, "L")
                    )
    );
    final List<Product> products = productDao.findBySize("S");
    assertProductsWithIds(products, 10L, 11L);
}
{% endhighlight %}

### Asserting table content

Querying just data from your database is only half on the story. Often enough your SQL statements alter the database as well. It would be awesome to test these statements as well. Well, you can.

Daleq gives you ```DaleqSupport.assertTableInDatabase()```. You set up a table in the state you expect it to and then simply assert this expectation:

{% highlight java%}
daleq.insertIntoDatabase(
	aTable(ProductTable.class).with(aRow(0).f(SIZE, "S")) );
// this is trivial!
daleq.assertTableInDatabase(
	aTable(ProductTable.class).with(aRow(0).f(SIZE, "S")) );
)
{% endhighlight %}

Usually you have something like this

{% highlight java%}
@Test
public void saveAll_should_inserAllThoseProducts() {
    final List<Product> products = Lists.newArrayList(
            aProduct("p1", aPrice(100), "S1"),
            aProduct("p2", aPrice(200), "S2"),
            aProduct("p3", aPrice(300), "S3"),
            aProduct("p4", aPrice(400), "S4")
    );
    productDao.saveAll(products);
    final Table expected = aTable(ProductTable.class).with(
            aRow(1).f(NAME, "p1").f(PRICE, "1.00").f(SIZE, "S1"),
            aRow(2).f(NAME, "p2").f(PRICE, "2.00").f(SIZE, "S2"),
            aRow(3).f(NAME, "p3").f(PRICE, "3.00").f(SIZE, "S3"),
            aRow(4).f(NAME, "p4").f(PRICE, "4.00").f(SIZE, "S4")
    );
    daleq.assertTableInDatabase(expected, ID);
}
{% endhighlight %}
Note the ID parameter on ```assertTableInDatabase()```. Usually your primary key will be generated by a sequence. So whenever you insert a new row into your table with your production code, you will not have control of the ID's actual value. Therefore Daleq allows you to ignore columns in the assertion.
